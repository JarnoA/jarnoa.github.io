<!DOCTYPE html>
<html lang="fi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Computer Says Yes Lab | Kutsu tekoälyttömyyteen</title>
  <link href="https://fonts.googleapis.com/css2?family=Abril+Fatface&family=Righteous&family=Space+Grotesk:wght@300;400;500;700&display=swap" rel="stylesheet" />
  <style>
    :root{
      --bg:#0a0a0a; --ink:#fffaeb; --accent:#ff8142; --accent2:#4fa8cc; --card:#121212; --highlight:#ffbe3c;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; font-family:"Space Grotesk",system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:var(--bg); color:var(--ink);}
    a{color:inherit}

    /* Layout */
    .container{max-width:1100px; margin:0 auto; padding:0 24px}
    section{padding:96px 0; position:relative}

    /* Hero */
    .hero{min-height:100vh; display:flex; align-items:center; justify-content:center; text-align:center; overflow:hidden;}
    .hero-canvas{position:absolute; inset:0; z-index:0}
    .hero-content{position:relative; z-index:1}

    h1{font-family:"Abril+Fatface",serif; font-size:clamp(2.8rem,7vw,6rem); line-height:1.02; letter-spacing:.2px; margin:0 0 12px}
    .subtitle{font-family:"Righteous",sans-serif; color:var(--highlight); font-size:clamp(1.1rem,2.2vw,1.5rem); margin:0 0 16px}
    p.lead{max-width:62ch; margin:0 auto 8px; font-size:clamp(1.05rem,1.7vw,1.2rem); line-height:1.7}

    /* Sections */
    .section-dark{background:var(--card)}
    .section-yellow{background:var(--highlight); color:#0a0a0a}
    .section-yellow h2, .section-yellow h3{color:#0a0a0a}

    h2{font-family:"Abril+Fatface",serif; font-size:clamp(2rem,4.5vw,3.2rem); margin:0 0 16px}
    h3{font-weight:700; font-size:clamp(1.2rem,2.2vw,1.5rem); margin:20px 0 8px}
    p{max-width:70ch; line-height:1.7}

    /* Grid */
    .grid{display:grid; gap:32px}
    .grid-2{grid-template-columns:repeat(2,minmax(0,1fr))}
    .grid-4{grid-template-columns:repeat(4,minmax(0,1fr))}
    @media (max-width:900px){
      .grid-2{grid-template-columns:1fr}
      .grid-4{grid-template-columns:1fr}
    }

    .card{background:rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.08); border-radius:18px; padding:24px}
    .img-frame{border-radius:18px; overflow:hidden; border:1px solid rgba(255,255,255,.08)}
    .img{width:100%; display:block}
    #explodeCanvas{display:block; width:100%; height:380px;}
    .center{text-align:center}
  </style>
  <script src="https://cdn.counter.dev/script.js" data-id="4dd6d014-e826-4cda-8265-b742387017fc" data-utcoffset="2"></script>
</head>
<body>
  <!-- HERO -->
  <section class="hero" id="hero">
    <canvas id="csy-scene" class="hero-canvas"></canvas>
    <div class="hero-content container">
      <h1>Computer Says Yes Lab</h1>
      <p class="subtitle">Kutsu viisaaseen tekoälyttömyyteen.</p>
      <p class="lead">CSY Lab on työskentelyalusta, joka pureutuu tekoälyn mustaan laatikkoon ja paljastaa ihmisyyden rajat. Tutkimme ja havainnollistamme, mitä tapahtuu, kun ulkoistamme ajattelun koneille – ja mitä inhimillistä meille silloin jää. Lähestymme tekoälyä kriittisesti, luovasti ja ennen kaikkea inhimillisestä näkökulmasta.</p>
      <p class="lead">Maailmassa, jossa kone sanoo kyllä, meidän on kysyttävä miksi.</p>
    </div>
  </section>

  <!-- AJATUS -->
  <section class="section-dark">
    <div class="container grid grid-2">
      <div>
        <h2>Ajatus</h2>
        <p>Tekoäly telakalla; se on kulttuurinen ja moraalinen ilmiö, joka heijastaa ja vahvistaa yhteiskuntamme vinoumia. Labimme tarjoaa organisaatioille välineet nähdä tekoäly peilinä, joka paljastaa omat sokeat pisteemme ja narsistisen taipumuksemme.</p>
        <p>Autamme ymmärtämään, miten järjestelmät hyödyntävät kognitiivista sokerisiirappia muokatakseen valintojamme. Tavoitteena on auttaa organisaatioita kysymään oikeita kysymyksiä – ja välttämään olemasta älykkäiden koneiden tyhmiä käyttäjiä.</p>
      </div>
      <div class="img">
        <img src="/images/robotdog.png" alt="Robot and Dog" class="img" />
      </div>
    </div>
  </section>

  <!-- MITÄ LAB TEKEE -->
  <section class="section-yellow">
    <div class="container">
      <h2>Mitä CSY Lab tekee</h2>
      <div class="grid grid-2">
        <div class="card">
          <h3>Asiantuntijaluennot ja koulutukset</h3>
          <p>Tekno-filosofisia puheenvuoroja tekoälystä, ihmisyydestä ja päätöksenteon tulevaisuudesta. Keskitymme ymmärtämään tekoälyjärjestelmien perusperiaatteita ja toimintalogiikkaa – emme vain yksittäisiä sovelluksia, kuten ChatGPT:n käyttöä.</p>
        </div>
        <div class="card">
          <h3>Työpajat</h3>
          <p>Käytännön harjoituksia ja sparrausta, jotka tukevat kriittisen hitaan ajattelun ja algoritmisen lukutaidon kehittämistä. Autamme organisaatioita sietämään monimutkaisuutta ja epäselvyyttä tekoälyyn liittyvässä päätöksenteossa.</p>
        </div>
        <div class="card">
          <h3>Koulutus ja konsultointi</h3>
          <p>Konsultoin organisaatioita tekoälyn strategisessa käyttöönotossa ja koulutan henkilöstöä hyödyntämään tekoälyä tehokkaasti arjessaan. Lähestyn tekoälyä sekä käytännön työkaluna että kulttuurisena ilmiönä – tuon kokemusta siitä, miten tekoäly todella tuottaa arvoa liiketoimintaprosesseissa ilman, että ulkoistamme ajattelun kokonaan koneille.</p>
        </div>
        <div class="card">
          <h3>Tutkimus ja taide</h3>
          <p>Toteutamme kokeellisia projekteja, joissa testaamme tekoälyn rajoja luovassa työssä. Tutkimme, miten algoritmit tulkitsevat merkityksiä, luovat sisältöä ja tekevät valintoja – ja mitä nämä prosessit paljastavat ihmisen ajattelusta. Tulokset näkyvät installaatioina, julkaisuina ja keskustelunavauksina, jotka laittavat sekä koneen että ihmisen uuteen valoon.</p>
        </div>
      </div>
    </div>
  </section>

    <!-- TYÖKALUT -->
  <section class="section-dark" id="tools" style="position:relative; overflow:hidden;">
    <canvas id="tools-bg" class="hero-canvas"></canvas>
    <div class="container" style="position:relative; z-index:1;">
      <h2>Työkalut & Projektit</h2>
      <div class="grid grid-2">
        <div class="card">
          <h3><a href="https://csy.fi/ai-energy-calculator/" target="_blank" rel="noopener noreferrer">AI Energy Calculator</a></h3>
          <p>Arvioi ja vertaile, kuinka paljon energiaa ja vettä kuluu luovassa työssä – käsin tehden tai tekoälyn avulla.</p>
        </div>
        <div class="card">
          <h3><a href="https://avain.net/tuote/jarno-alastalo/musta-laatikko-teko%C3%A4lytt%C3%B6myyden-ajan-alku/9789523046559" target="_blank" rel="noopener noreferrer">Musta laatikko -kirja</a></h3>
          <p>Musta laatikko on tutkimusmatka maailmaan, jossa algoritmit, tekoäly ja näkymättömät järjestelmät muokkaavat tunteitamme, valintojamme ja yhteisöjämme. Olemme astuneet tekoälyttömyyden aikaan: joko tulemme älykkäiden koneiden tyhmiksi käyttäjiksi tai opimme käyttämään niitä viisaasti. Tekoäly toimii mustassa laatikossa, järjestelmässä, jonka toimintaa emme näe, mutta jonka vaikutukset tunnemme. Mitä tapahtuu, kun tekoälystä tulee opettaja, ystävä ja peili? Jos tekoäly valitsisi viisaasti, antaisitko sen päättää elämästäsi? Tai kuolemastasi? Tämä kirja kutsuu sinut katsomaan pinnan alle.</p>
        </div>
      </div>
    </div>
  </section>

  <!-- THREE.JS LIBRARY FIX: Moved the script here so it loads before any custom code -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>

  <!-- START: JS Scripts for Animations -->
  <script>
    // ================
    // TOOLS BACKGROUND
    // ================
    (function(){
      const canvas = document.getElementById('tools-bg');
      if(!canvas) return;
      const renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true});
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 50);
      camera.position.z = 5;

      const count = 800;
      const positions = new Float32Array(count * 3);
      for(let i=0;i<count;i++){
        positions[i*3]   = (Math.random()-0.5)*10;
        positions[i*3+1] = (Math.random()-0.5)*6;
        positions[i*3+2] = (Math.random()-0.5)*8;
      }
      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.BufferAttribute(positions,3));

      const mat = new THREE.PointsMaterial({
        color:0xff8142,
        size:0.03,
        transparent:true,
        opacity:0.7,
        blending:THREE.AdditiveBlending
      });
      const points = new THREE.Points(geo, mat);
      scene.add(points);

      const geo2 = geo.clone();
      const mat2 = new THREE.PointsMaterial({
        color:0x4fa8cc,
        size:0.02,
        transparent:true,
        opacity:0.6,
        blending:THREE.AdditiveBlending
      });
      const points2 = new THREE.Points(geo2, mat2);
      scene.add(points2);

      function resize(){
        const rect = canvas.parentElement.getBoundingClientRect();
        renderer.setSize(rect.width, rect.height, false);
        camera.aspect = rect.width / rect.height;
        camera.updateProjectionMatrix();
      }
      window.addEventListener('resize', resize);
      resize();

      let bg_t = 0;
      function animate(){
        requestAnimationFrame(animate);
        bg_t += 0.001;
        points.rotation.y += 0.0008;
        points2.rotation.y -= 0.001;
        points.position.x = Math.sin(bg_t*4)*0.1;
        points2.position.y = Math.sin(bg_t*3)*0.1;
        renderer.render(scene, camera);
      }
      animate();
    })();
  </script>

  <!-- ANIMAATIO: Purkautuva kone -->
  <section class="section-yellow" style="padding:0; overflow:hidden;">
    <canvas id="explodeCanvas"></canvas>
  </section>

  <!-- TAVOITE -->
  <section class="section-dark">
    <div class="container">
      <h2>Tavoite</h2>
      <p>Auttaa organisaatioita kehittämään tekoälyä, joka ymmärtää ihmistä – ei korvaa häntä.</p>
      <p><em>Tekoälyttömyys ei ole paluuta menneeseen, vaan muistutus siitä, että teknologia tarvitsee ihmisen rinnalleen – ei hänen tilalleen. Tavoitteenamme on kuroa umpeen digitaalinen kuilu ja palauttaa toimijuus organisaatioille, jotta voitte kehittää tekoälyä, joka tukee ihmisen kykyä ajatella.</em></p>
    </div>
  </section>

  <!-- YHTEYS -->
  <section class="section-yellow">
    <div class="container">
      <h2>Ota yhteyttä</h2>
      <p>Jarno Alastalo</p>
      <p><strong>jarno@csy.fi</strong></p>
      <p>Jarno Alastalo on tekno-filosofi, kirjailija, digitaalisten yhteisöjen rakentaja ja kissavideoiden asiantuntija, joka on suunnitellut mustia laatikoita. Hän tarkastelee teknologiaa inhimillisestä näkökulmasta: miten tekoäly, sosiaalinen media ja algoritmit muokkaavat ihmisyyttä, identiteettiä ja arvoja.</p>
      <p><strong>CSY Lab, Y-tunnus 2578992-5 (osa MPH Making People Happy -yritystä)</strong></p>
      <p></p>
      <p><i>Sivusto käyttää evästeetöntä Counter.dev-kävijätilastointia, jonka avulla seurataan sivun käyttöä anonyymisti. Tietoja ei käytetä markkinointiin eikä yksittäisiä kävijöitä voi tunnistaa.</i></p>
    </div>
  </section>

  <script>
    // === HERO ANIMATION: STYLIZED ANIMATION-STYLE EARTH WITH EXAGGERATED FEATURES ===
    (function(){ 
        const canvas = document.getElementById('csy-scene');
        const renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true});
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(40, 1, 0.1, 100);
        
        camera.position.set(0, 1.2, 4.5); 
        camera.lookAt(0, 0, 0); 

        function resize(){
          const rect = document.getElementById('hero').getBoundingClientRect();
          renderer.setSize(rect.width, rect.height, false);
          camera.aspect = rect.width / rect.height; 
          camera.updateProjectionMatrix();
        }
        window.addEventListener('resize', resize);

        let mx = 0, my = 0; 
        window.addEventListener('mousemove', (e)=>{
          const x = (e.clientX / window.innerWidth) * 2 - 1;
          const y = (e.clientY / window.innerHeight) * 2 - 1;
          mx = x*0.25; my = y*0.1;
        });

        // Bright, Cartoon-style lighting
        const ambient = new THREE.AmbientLight(0xffffff, 0.8);
        const sun = new THREE.DirectionalLight(0xffffff, 1.2);
        sun.position.set(5, 10, 7);
        scene.add(ambient, sun);

        const worldGroup = new THREE.Group();
        scene.add(worldGroup);

        // --- PROCEDURAL LAND LOGIC ---
        function getIsLand(x, y, z) {
          // Simple noise-like function to determine continents
          const n = Math.sin(x * 2.5) * Math.cos(y * 2.5) + Math.sin(z * 2.5 + 1);
          return n > 0.15;
        }

        // --- THE PLANET CORE (WATER) ---
        const globeRadius = 1.3;
        const waterGeo = new THREE.SphereGeometry(globeRadius, 40, 40);
        const waterMat = new THREE.MeshStandardMaterial({
            color: 0x00aaff, 
            roughness: 0.3,
            metalness: 0.1
        });
        const ocean = new THREE.Mesh(waterGeo, waterMat);
        worldGroup.add(ocean);

        // --- MANTEREET (LANDMASSES) ---
        const landGeo = new THREE.SphereGeometry(globeRadius * 1.01, 60, 60);
        const colorsAttribute = new Float32Array(landGeo.attributes.position.count * 3);
        const landPos = landGeo.attributes.position.array;
        
        for (let i = 0; i < landGeo.attributes.position.count; i++) {
          const x = landPos[i*3], y = landPos[i*3+1], z = landPos[i*3+2];
          const isLand = getIsLand(x, y, z);
          const color = isLand ? new THREE.Color(0x44cc44) : new THREE.Color(0x00aaff);
          colorsAttribute[i*3] = color.r;
          colorsAttribute[i*3+1] = color.g;
          colorsAttribute[i*3+2] = color.b;
        }
        landGeo.setAttribute('color', new THREE.BufferAttribute(colorsAttribute, 3));
        const landMat = new THREE.MeshStandardMaterial({ 
          vertexColors: true, 
          flatShading: true,
          roughness: 0.8
        });
        const land = new THREE.Mesh(landGeo, landMat);
        worldGroup.add(land);

        // --- EXAGGERATED FEATURES: BUILDINGS, TOWERS, TREES ---
        const featureGroup = new THREE.Group();
        worldGroup.add(featureGroup);

        const houseMat = new THREE.MeshStandardMaterial({ color: 0xfffaeb });
        const roofMat = new THREE.MeshStandardMaterial({ color: 0xff8142 });
        const towerMat = new THREE.MeshStandardMaterial({ color: 0xcccccc });
        const treeMat = new THREE.MeshStandardMaterial({ color: 0x22ee66 });
        const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });

        function createFeature() {
          const phi = Math.random() * Math.PI * 2;
          const theta = Math.random() * Math.PI * 2;
          
          const x = globeRadius * Math.sin(phi) * Math.cos(theta);
          const y = globeRadius * Math.sin(phi) * Math.sin(theta);
          const z = globeRadius * Math.cos(phi);

          if (!getIsLand(x, y, z)) return; // Only place on land

          const container = new THREE.Group();
          const type = Math.random();
          
          if (type < 0.3) {
            // House
            const base = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.12, 0.12), houseMat);
            const roof = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.1, 4), roofMat);
            roof.position.y = 0.11;
            roof.rotation.y = Math.PI/4;
            container.add(base, roof);
          } else if (type < 0.5) {
            // Tower
            const tower = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.35, 0.08), towerMat);
            container.add(tower);
          } else {
            // Tree
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.05), trunkMat);
            const leaves = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.2, 5), treeMat);
            leaves.position.y = 0.1;
            container.add(trunk, leaves);
          }

          container.position.set(x, y, z);
          container.lookAt(0,0,0);
          container.rotateX(-Math.PI/2);
          
          // Exaggerated scale
          const s = 1.0 + Math.random() * 0.8;
          container.scale.set(s,s,s);
          featureGroup.add(container);
        }

        for(let i=0; i<80; i++) createFeature();

        // Position globe at the horizon line (bottom) - LOWERED to avoid text overlap
        worldGroup.position.y = -1.7;

        // --- STARS ---
        const starGeo = new THREE.BufferGeometry();
        const starCount = 500;
        const starArr = new Float32Array(starCount * 3);
        for(let i=0; i<starCount; i++){
            starArr[i*3] = (Math.random()-0.5)*20;
            starArr[i*3+1] = (Math.random()-0.5)*15;
            starArr[i*3+2] = (Math.random()-0.5)*15;
        }
        starGeo.setAttribute('position', new THREE.BufferAttribute(starArr, 3));
        const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({color: 0xffbe3c, size: 0.03}));
        scene.add(stars);

        let t = 0;
        function tick(){
          requestAnimationFrame(tick); t += 0.005;
          worldGroup.rotation.y += 0.002;
          worldGroup.rotation.x += 0.0003;
          
          // Subtle animation for features
          featureGroup.scale.setScalar(1 + Math.sin(t*2)*0.015);
          
          camera.position.x += (mx - camera.position.x) * 0.05;
          camera.position.y += (1.2 - my - camera.position.y) * 0.05;
          
          stars.rotation.y += 0.0001;
          renderer.render(scene, camera);
        }
        resize(); tick();
    })();

    // =========================
    // EXPLODING CUBE ANIMATION
    // =========================
    (function(){
      const expCanvas = document.getElementById('explodeCanvas');
      if(!expCanvas) return;
      const expRenderer = new THREE.WebGLRenderer({canvas: expCanvas, antialias:true, alpha:true});
      const expScene = new THREE.Scene();
      const expCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 50);
      expCamera.position.set(0, 0.6, 4);
      expScene.add(new THREE.AmbientLight(0xffffff, 0.7), new THREE.DirectionalLight(0xff8142, 1.1));

      const step = 0.2, half = 1.2, pts = [];
      for(let x=-half; x<=half; x+=step){
        for(let y=-half; y<=half; y+=step){
          for(let z=-half; z<=half; z+=step){
            if(Math.abs(Math.abs(x)-half)<1e-6 || Math.abs(Math.abs(y)-half)<1e-6 || Math.abs(Math.abs(z)-half)<1e-6) pts.push(x,y,z);
          }
        }
      }
      const basePositions = new Float32Array(pts);
      const geom = new THREE.BufferGeometry();
      geom.setAttribute('position', new THREE.BufferAttribute(basePositions.slice(), 3));
      const colors = new Float32Array((basePositions.length/3)*3);
      for(let i=0; i<colors.length/3; i++){
        const c = new THREE.Color(0xff8142).lerp(new THREE.Color(0x4fa8cc), (i % 60) / 60);
        colors[i*3]=c.r; colors[i*3+1]=c.g; colors[i*3+2]=c.b;
      }
      geom.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      const cloud = new THREE.Points(geom, new THREE.PointsMaterial({vertexColors:true, size:0.06}));
      expScene.add(cloud);
      const normals = new Float32Array(basePositions.length);
      for(let i=0; i<basePositions.length; i+=3){
        const len=Math.hypot(basePositions[i],basePositions[i+1],basePositions[i+2])||1;
        normals[i]=basePositions[i]/len; normals[i+1]=basePositions[i+1]/len; normals[i+2]=basePositions[i+2]/len;
      }
      function resizeExp(){
        const rect = expCanvas.parentElement.getBoundingClientRect();
        expRenderer.setSize(rect.width, 380, false);
        expCamera.aspect = rect.width / 380; expCamera.updateProjectionMatrix();
      }
      window.addEventListener('resize', resizeExp); resizeExp();
      let tt = 0; function tickExp(){
        requestAnimationFrame(tickExp); tt += 0.016;
        const explode = (Math.sin(tt*0.9)*0.5 + 0.5);
        const pos = geom.getAttribute('position');
        for(let i=0; i<pos.array.length; i+=3){
          pos.array[i]   = basePositions[i] + normals[i]*0.8*explode;
          pos.array[i+1] = basePositions[i+1] + normals[i+1]*0.8*explode;
          pos.array[i+2] = basePositions[i+2] + normals[i+2]*0.8*explode;
        }
        pos.needsUpdate = true; cloud.rotation.y += 0.003; expRenderer.render(expScene, expCamera);
      }
      tickExp();
    })();
  </script>
</body>
</html>