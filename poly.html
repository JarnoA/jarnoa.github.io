<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Low Poly Earth - V10 Tesla Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: radial-gradient(circle at center, #1b2735 0%, #090a0f 100%); }
        canvas { display: block; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 1. SKEENE JA KAMERA ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 45); // Hieman kauemmas, jotta Tesla mahtuu kuvaan

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // --- 2. VALAISTUS ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const sunLight = new THREE.DirectionalLight(0xffffff, 2.0);
        sunLight.position.set(-25, 15, 25);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048; sunLight.shadow.mapSize.height = 2048;
        scene.add(sunLight);

        // --- 3. VIRTUAALINEN KARTTAGENERAATTORI ---
        function generateWorldMap() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 256; const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#000000'; ctx.fillRect(0, 0, 512, 256);
            ctx.fillStyle = '#FFFFFF';
            ctx.beginPath(); ctx.moveTo(100, 20); ctx.lineTo(160, 20); ctx.lineTo(180, 80);
            ctx.lineTo(140, 120); ctx.lineTo(160, 140); ctx.lineTo(190, 180);
            ctx.lineTo(170, 220); ctx.lineTo(130, 180); ctx.lineTo(120, 130); ctx.lineTo(80, 60); ctx.fill();
            ctx.beginPath(); ctx.moveTo(240, 30); ctx.lineTo(300, 30); ctx.lineTo(350, 50);
            ctx.lineTo(400, 40); ctx.lineTo(420, 100); ctx.lineTo(360, 140);
            ctx.lineTo(320, 120); ctx.lineTo(330, 150); ctx.lineTo(300, 200);
            ctx.lineTo(250, 160); ctx.lineTo(230, 100); ctx.lineTo(220, 60); ctx.fill();
            ctx.beginPath(); ctx.arc(400, 180, 15, 0, Math.PI*2); ctx.fill();
            return ctx;
        }

        // --- 4. MAAPALLON RAKENNUS ---
        const mapContext = generateWorldMap();
        const mapData = mapContext.getImageData(0, 0, 512, 256).data;
        let earthGeometry = new THREE.IcosahedronGeometry(11, 4);
        earthGeometry = earthGeometry.toNonIndexed(); 
        const pos = earthGeometry.attributes.position;
        const colors = [];
        const count = pos.count;
        const cOcean = new THREE.Color(0x1e6091);
        const cLand = new THREE.Color(0x5a8035);
        const cForest = new THREE.Color(0x3e5e26);
        const cSand = new THREE.Color(0xe0cd85);
        const cMountain = new THREE.Color(0xffffff);
        const _v = new THREE.Vector3();
        for (let i = 0; i < count; i += 3) {
            _v.set(pos.getX(i), pos.getY(i), pos.getZ(i)); _v.normalize();
            const u = 0.5 + (Math.atan2(_v.z, _v.x) / (2 * Math.PI));
            const v = 0.5 + (Math.asin(_v.y) / Math.PI);
            const pxX = Math.floor(u * 512); const pxY = Math.floor((1 - v) * 256);
            const index = (pxY * 512 + pxX) * 4;
            const brightness = mapData[index];
            let finalColor;
            if (brightness > 100) {
                const h = 1.03;
                for(let j=0; j<3; j++) pos.setXYZ(i+j, pos.getX(i+j)*h, pos.getY(i+j)*h, pos.getZ(i+j)*h);
                const r = Math.random();
                if (Math.abs(_v.y) > 0.85) finalColor = cMountain;
                else if (r > 0.7) finalColor = cForest;
                else if (r < 0.1) finalColor = cSand;
                else finalColor = cLand;
            } else {
                const deep = 1 - Math.random() * 0.15;
                finalColor = cOcean.clone().multiplyScalar(deep);
            }
            colors.push(finalColor.r, finalColor.g, finalColor.b, finalColor.r, finalColor.g, finalColor.b, finalColor.r, finalColor.g, finalColor.b);
        }
        earthGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        earthGeometry.computeVertexNormals();
        const earthMaterial = new THREE.MeshStandardMaterial({ vertexColors: true, flatShading: true, roughness: 0.8, metalness: 0.1 });
        const earth = new THREE.Mesh(earthGeometry, earthMaterial);
        earth.castShadow = true; earth.receiveShadow = true;
        earth.rotation.y = -1.8; 
        scene.add(earth);

        // --- 5. PILVET (Kulmikkaat) ---
        function createCloud() {
            const group = new THREE.Group();
            const blobs = 4 + Math.floor(Math.random() * 5);
            const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, flatShading: true, roughness: 0.5 });
            for(let k=0; k<blobs; k++){
                const geom = new THREE.DodecahedronGeometry(1.2 + Math.random() * 0.5, 0);
                const mesh = new THREE.Mesh(geom, mat);
                mesh.position.set((Math.random()-0.5)*5, (Math.random()-0.5)*2, (Math.random()-0.5)*3);
                mesh.rotation.set(Math.random()*3, Math.random()*3, 0);
                mesh.castShadow = true;
                group.add(mesh);
            }
            return group;
        }

        // --- HAHMO 1: RETRO-ROBOTTI (KORJATTU POSITIO) ---
        function createRetroRobot() {
            const robotGroup = new THREE.Group();
            const matBody = new THREE.MeshStandardMaterial({ color: 0x888899, flatShading: true, metalness: 0.6 });
            const matEyes = new THREE.MeshBasicMaterial({ color: 0xffcc00 });
            const body = new THREE.Mesh(new THREE.BoxGeometry(1, 1.2, 0.8), matBody);
            robotGroup.add(body);
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.8), matBody);
            head.position.y = 1.0; robotGroup.add(head);
            const eyeGeom = new THREE.BoxGeometry(0.15, 0.15, 0.1);
            const eyeL = new THREE.Mesh(eyeGeom, matEyes); eyeL.position.set(-0.2, 1.05, 0.41); robotGroup.add(eyeL);
            const eyeR = eyeL.clone(); eyeR.position.x = 0.2; robotGroup.add(eyeR);
            const legGeom = new THREE.BoxGeometry(0.3, 0.6, 0.3);
            const legL = new THREE.Mesh(legGeom, matBody); legL.position.set(-0.3, -0.8, 0.2); legL.rotation.x = -Math.PI/6; robotGroup.add(legL);
            const legR = legL.clone(); legR.position.x = 0.3; robotGroup.add(legR);
            robotGroup.scale.set(0.6, 0.6, 0.6);
            robotGroup.traverse(c => { if(c.isMesh) c.castShadow = true; });
            return robotGroup;
        }

        // --- HAHMO 2: LOW-POLY KISSA ---
        function createLowPolyCat() {
            const catGroup = new THREE.Group();
            const matOrange = new THREE.MeshStandardMaterial({ color: 0xd18e47, flatShading: true });
            const body = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.5, 0.5), matOrange); catGroup.add(body);
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), matOrange); head.position.set(0.7, 0.2, 0); catGroup.add(head);
            const earGeom = new THREE.ConeGeometry(0.15, 0.3, 4);
            const ear1 = new THREE.Mesh(earGeom, matOrange); ear1.position.set(0.7, 0.6, 0.2); ear1.rotation.y = Math.PI/4; catGroup.add(ear1);
            const ear2 = ear1.clone(); ear2.position.z = -0.2; catGroup.add(ear2);
            const tail = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.2, 0.2), matOrange); tail.position.set(-0.7, 0.3, 0); tail.rotation.z = Math.PI/4; catGroup.add(tail);
            catGroup.scale.set(0.5, 0.5, 0.5);
            catGroup.traverse(c => { if(c.isMesh) c.castShadow = true; });
            return catGroup;
        }

        // --- UUSI: LOW-POLY TESLA + OLIGARKKI AURINKOLASEILLA ---
        function createTeslaWithOligarch() {
            const carGroup = new THREE.Group();

            // Materiaalit
            const matCarGrey = new THREE.MeshStandardMaterial({ color: 0x777777, flatShading: true, metalness: 0.5 });
            const matWindowDark = new THREE.MeshStandardMaterial({ color: 0x111111, flatShading: true, metalness: 0.9, roughness: 0.1 });
            const matWheel = new THREE.MeshStandardMaterial({ color: 0x222222, flatShading: true });
            
            // Auton runko (yksinkertaistettu laatikko-Tesla)
            const chassis = new THREE.Mesh(new THREE.BoxGeometry(4, 0.8, 1.8), matCarGrey);
            carGroup.add(chassis);
            // Ohjaamo (tumma lasilaatikko)
            const cabin = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.7, 1.6), matWindowDark);
            cabin.position.set(-0.2, 0.75, 0);
            carGroup.add(cabin);
            // Pyörät (4 sylinteriä kyljellään)
            const wheelGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 8);
            wheelGeo.rotateX(Math.PI/2);
            const w1 = new THREE.Mesh(wheelGeo, matWheel); w1.position.set(1.2, -0.2, 0.9); carGroup.add(w1);
            const w2 = new THREE.Mesh(wheelGeo, matWheel); w2.position.set(-1.2, -0.2, 0.9); carGroup.add(w2);
            const w3 = new THREE.Mesh(wheelGeo, matWheel); w3.position.set(1.2, -0.2, -0.9); carGroup.add(w3);
            const w4 = new THREE.Mesh(wheelGeo, matWheel); w4.position.set(-1.2, -0.2, -0.9); carGroup.add(w4);

            // Oligarkki istumaan auton sisään
            const oligarchGroup = new THREE.Group();
            const matSuit = new THREE.MeshStandardMaterial({ color: 0x223355, flatShading: true });
            const matSkin = new THREE.MeshStandardMaterial({ color: 0xffdbac, flatShading: true });
            const matSunglasses = new THREE.MeshStandardMaterial({ color: 0x000000, flatShading: true, metalness: 1.0, roughness: 0.0 });

            // Vartalo (lyhennetty, koska istuu)
            const torso = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.8, 0.4), matSuit);
            oligarchGroup.add(torso);
            // Pää
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.6, 0.5), matSkin);
            head.position.y = 0.7;
            oligarchGroup.add(head);
            // Aurinkolasit (kiiltävä musta laatikko silmillä)
            const glasses = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.15, 0.1), matSunglasses);
            glasses.position.set(0, 0.75, 0.28);
            oligarchGroup.add(glasses);

            // Sijoitetaan oligarkki autoon niin että pää näkyy ohjaamosta
            oligarchGroup.position.set(-0.5, 0.5, 0);
            oligarchGroup.scale.set(0.8, 0.8, 0.8);
            carGroup.add(oligarchGroup);

            carGroup.scale.set(0.6, 0.6, 0.6);
            carGroup.traverse(c => { if(c.isMesh) c.castShadow = true; });
            return carGroup;
        }


        // --- PILVIEN JA HAHMOJEN SIJOITTELU ---
        for(let i=0; i<12; i++){
            const cloud = createCloud();
            
            // Pilvi 3: Robotti (Korjattu korkeus)
            if (i === 3) {
                const robot = createRetroRobot();
                // Laskettu alemmas (oli 1.8), nyt istuu paremmin pilvessä
                robot.position.y = 1.2; 
                robot.rotation.y = Math.PI; 
                cloud.add(robot);
            }

            // Pilvi 6: Kissa (Siirretty omaan pilveen)
            if (i === 6) {
                const cat = createLowPolyCat();
                cat.position.y = 1.3;
                cat.rotation.y = Math.PI / 2;
                cloud.add(cat);
            }

            const angle = (i / 12) * Math.PI * 2;
            const dist = 22 + Math.random() * 3;
            cloud.position.x = Math.cos(angle) * dist;
            cloud.position.z = Math.sin(angle) * dist;
            cloud.position.y = (Math.random()-0.5) * 6;
            cloud.lookAt(0,0,0);
            scene.add(cloud);
        }

        // --- LISÄTÄÄN AVARUUS-TESLA ERIKSEEN SKENEEN ---
        const spaceTesla = createTeslaWithOligarch();
        // Sijoitetaan kauemmas kuin pilvet
        spaceTesla.position.set(35, 5, 0); 
        // Käännetään hieman vinoon lentokulmaan
        spaceTesla.rotation.set(0.2, Math.PI/2, 0.1);
        scene.add(spaceTesla);


        // --- 6. TÄHTITAIVAS ---
        const starGeo = new THREE.BufferGeometry();
        const starPos = [];
        for(let i=0; i<800; i++){ starPos.push((Math.random()-0.5)*400, (Math.random()-0.5)*400, (Math.random()-0.5)*400); }
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
        const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({color: 0xffffff, size: 0.2}));
        scene.add(stars);

        // --- 7. ANIMAATIO ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            stars.rotation.y -= 0.0003; 
            earth.rotation.y += 0.0005; 

            // Anavoidaan Teslaa lentämään maapallon ympäri
            const time = Date.now() * 0.0005;
            spaceTesla.position.x = Math.cos(time) * 35;
            spaceTesla.position.z = Math.sin(time) * 35;
            // Käännetään autoa lentosuuntaan
            spaceTesla.rotation.y = -time + Math.PI/2;

            renderer.render(scene, camera);
        }
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        animate();
    </script>
</body>
</html>